# One&#45;Way Phone Storage Strategies

This doc explains practical strategies to avoid storing direct phone numbers in clear text, while preserving lookups (e.g., login by phone) and uniqueness constraints.

Important security notes:
- Never trust client input; re&#45;validate on the server (e.g., normalize to E.164) [^1].
- Do not rely on encryption alone. Apply defense&#45;in&#45;depth: access control, rate limiting, monitoring, and audits [^1].

## Goals

- Avoid storing raw phoneNumber
- Preserve ability to:
  - Check uniqueness (prevent duplicate accounts)
  - Lookup by a phone input during login
- Keep SMS/OTP delivery possible

## Strategy A: Deterministic HMAC (Recommended)

- Normalize user input to E.164 (e.g., +14155550123)
- Compute an HMAC over the normalized number:
  - phone_hash = HMAC&#45;SHA256(secret_pepper, e164_phone)
  - secret_pepper is a server&#45;side secret (rotateable)
- Store phone_hash (unique indexed)
- Do not store raw phoneNumber
- Keep only what you need for UI (e.g., last 2&#45;4 digits or a masked form) if you must display something

Pros:
- One&#45;way (irreversible) without the pepper
- Deterministic: same input produces the same output, enabling lookups #43; uniqueness
- Works well for login flows

Cons:
- If you need to send SMS later independently, you cannot derive the phone. You must ask user for the phone on each OTP send.

Code sample (Node.js):

\`\`\`ts
import crypto from "crypto"

export function normalizeE164(input: string) {
  // Use a robust lib in production. Here assume already E.164.
  return input.trim()
}

export function hmacPhone(e164: string, pepper: string) {
  return crypto.createHmac("sha256", pepper).update(e164).digest("hex")
}

// Usage
// const e164 = normalizeE164("+14155550123")
// const hash = hmacPhone(e164, process.env.PHONE_HMAC_PEPPER!)
\`\`\`

MongoDB index:
- Create a unique index on user_auth.phoneHash

Login flow:
- User enters phone
- Normalize, compute HMAC, find user by phoneHash
- Send OTP to the user&#39;s entered phone (do not assume stored phone), verify, and then authenticate

## Strategy B: Salted Hash With Deterministic Salt

If HMAC is not available, you can derive a deterministic salt from a pepper:

- salt = HMAC&#45;SHA256(pepper, e164_phone).slice(0, 16)
- phone_hash = SHA256(salt || e164_phone)

It preserves determinism and uniqueness without storing raw.

## Strategy C: Split Storage (HMAC #43; Encrypted Phone under KMS)

If the system must send SMS later without asking the user again, store:
- phone_hash (HMAC) for primary lookup #43; uniqueness
- phone_enc: Encrypted phone number (AES&#45;GCM) using a key from a KMS (AWS KMS, HashiCorp Vault)
  - Access tightly controlled and audited
  - Use only for messaging
- All application logic uses phone_hash; only messaging accesses phone_enc

Pros:
- Enables outbound messaging without storing plaintext
- Clear audit trail around decrypt access

Cons:
- Introduces reversible encryption (not purely one&#45;way), but only within a restricted, audited path

## Strategy D: Tokenization Service

- Replace phones with tokens generated by a tokenization service
- The service keeps the mapping securely
- Your DB stores only tokens (and phone_hash for uniqueness)
- Messaging calls the tokenization service to resolve tokens when needed

## Display #43; Analytics Considerations

- Store last4 (not reversible to full phone) for UI
- Avoid logging phone or OTP in analytics/logs (both frontend and backend redaction) [^1]
- Treat phone as sensitive at rest and in transit

## Migration Plan

1. Add phoneHash field (unique index)
2. Backfill:
   - For each user with a plaintext phoneNumber, compute phoneHash via Strategy A
   - Optionally fill last4 and phone_enc (Strategy C) if needed
3. Update auth flows to use phoneHash lookup
4. Remove plaintext phoneNumber storage
5. Add guards to reject any code path that tries to persist plaintext

## Validation #43; Hardening

- Normalize/validate on server; do not trust client [^1]
- Rate limit OTP sends and login attempts
- Use audit logs for sensitive events (number changes, OTP, deletes)
- Use transport security and secure secrets management

[^1]: Guides: Data Security | Next.js
